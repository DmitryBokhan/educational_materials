Базовые настройки
```
$ git config --global user.name "User Namovich"
# имя или ник нужно написать латиницей и в кавычках

$ git config --global user.email username@yandex.ru
# здесь нужно указать свой настоящий email
```
----------------------------------------------------
````
#инициализация проекта
git init
````
````
#«Разгитить» папку
rm -rf .git
````
ключ -r recursive — «рекурсивно»
ключ -f force — «заставить»
-------------------------------------------------------------------------
Привязать удалённый репозиторий к локальному

$ cd ~/dev/first-project
$ git remote add origin git@github.com:%ИМЯ_АККАУНТА%/first-project.git  (ПРИМЕР: git remote add origin git@github.com:DmitryBokhan/first-project.git)

Команде необходимо передать два параметра: имя удалённого репозитория и его URL.
В качестве имени используйте слово origin. А URL вы скопировали со страницы удалённого репозитория.

origin (англ. «источник») — стандартный псевдоним, с помощью которого можно обращаться к главному удалённому репозиторию (обычно такой репозиторий один).
Это значительно упрощает работу.

Убедиться, что репозитории связаны, — git remote -v

$ git remote -v
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (fetch)
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (push)
В выводе вы должны увидеть две строчки, аналогичные тем, что показаны выше.
Флаг -v — короткая форма флага --verbose (англ. «подробный»). Он позволяет показать больше информации в выводе.

Отправить изменения на удалённый репозиторий — git push
Вы уже прошли весь «цикл коммита»: подготовили файлы с помощью git add, закоммитили их с комментарием командой git commit -m. Осталось загрузить содержимое локального репозитория на GitHub. За это отвечает команда git push (от англ. push — «толкать»).
В первый раз эту команду нужно вызвать с флагом -u и параметрами origin (имя удалённого репозитория) и main или master (название текущей ветки). Флаг -u свяжет локальную ветку с одноимённой удалённой. Как вы связывали локальный и удалённый репозитории в предыдущем уроке, так же и здесь нужно дополнительно связать ветки.
$ git push -u origin main # Если команда приведёт к ошибке, попробуйте
# заменить main на master.

----------------------------------------------------------------------------
Как исправить коммит

$ git add common.css
# добавили файл common.css в список на коммит как обычно

# но вместо команды commit -m '...'
# будет:
$ git commit --amend --no-edit

$ git log --oneline
8340eb2 Добавить главную страницу
# коммит в истории всё ещё один (но у него новый хеш)

--
# ещё раз отредактировали main.html

$ git add main.html # добавили в список на коммит
$ git commit --amend --no-edit

---
Изменить сообщение коммита

$ git commit --amend -m "Добавить главную страницу и стили"
$ git log --oneline
a31fa24 Добавить главную страницу и стили
---
Если забыть указать у команды git commit --amend один из флагов (--no-edit или -m), Git предложит отредактировать сообщение коммита вручную. Для этого он откроет текстовый редактор, который установлен в системе по умолчанию. Чаще всего это либо GNU nano, либо Vim.


----------------------------------------------------------------------------
Как откатиться назад, если «всё сломалось»

git restore --staged <file>
англ. restore — «восстановить»

В терминале это будет выглядеть примерно так.

$ touch example.txt # создали ненужный файл
$ git add example.txt # добавили его в staged

$ git status # проверили статус
Changes to be committed:
(use "git restore --staged <file>..." to unstage)
new file:   example.txt

$ git restore --staged example.txt
$ git status # проверили статус

Untracked files:
(use "git add <file>..." to include in what will be committed)
example.txt

no changes added to commit (use "git add" and/or "git commit -a")
# файл example.txt из staged вернулся обратно в untracked

--
«Откатить» коммит — git reset --hard <commit hash>

$ git log --oneline # хеш можно найти в истории
7b972f5 (HEAD -> master) style: добавить комментарии, расставить отступы
b576d89 feat: добавить массив Expenses и цикл для добавления трат # вот сюда и вернёмся
4b58962 refactor: разделить analyzeExpenses() на countSum() и saveExpenses()

$ git reset --hard b576d89
# теперь мы на этом коммите
HEAD is now at b576d89 feat: добавить массив Expenses и цикл для добавления трат
----------------------------------------------------------------------------
Как сравнить файлы
Команда git diff сравнит последнюю закоммиченную версию файла с той, что находится в состоянии modified.
Команда git diff --staged покажет изменения в staged-файлах относительно последних закоммиченных версий.
----------------------------------------------------------------------------
Игнорирование файлов в Git
.gitignore


Звёздочка (*)
# игнорировать все файлы, которые заканчиваются на .jpeg
*.jpeg

# игнорировать все файлы "tmp" во всех подпапках папки docs
docs/*/tmp

---
Вопросительный знак ? соответствует одному любому символу.
file?.txt
---
Квадратные скобки ([…])
# игнорировать файлы file0.txt, file1.txt и file2.txt
# при этом не игнорировать file3.txt, file4.txt, ...
file[0-2].txt
---
осая черта, или слеш (/), указывает на каталоги. Если шаблон в .gitignore начинается со слеша, то Git проигнорирует файлы или каталоги только в корневой директории.

# игнорировать todo.txt в корне репозитория
/todo.txt

# для сравнения: spam.txt будет игнорироваться во всех папках
spam.txt

Теперь файл todo.txt в корневом каталоге будет проигнорирован. При этом, например, файл subdir/todo.txt по-прежнему отслеживается.
Если шаблон заканчивается слешем, то правило применится только к папке.

# игнорировать папку build
build/

Обратите внимание: если build — это папка, то она будет проигнорирована. Если build — обычный файл, то он не подпадёт под правило и не будет игнорироваться.
---
Парные звёздочки (**)

# игнорировать файлы "docs/current/tmp", "docs/old/tmp",
# а также "docs/old/saved/a/b/c/d/tmp"
# и даже "docs/tmp", потому что ноль вложенных папок тоже подходит
docs/**/tmp

# игнорировать только "docs/current/tmp" и "docs/old/tmp"
# файл "docs/old/saved/a/b/c/d/tmp" не попадает в правило
docs/*/tmp

---
Восклицательный знак (!)
Любое правило в файле .gitignore можно инвертировать с помощью восклицательного знака (!).

# игнорировать все JPEG-файлы
*.jpeg

# но только не мем с Doge
!doge.jpeg
---
Пример файла .gitignore

# игнорировать все файлы в каталоге build
build/

# игнорировать все .log файлы
*.log

# не игнорировать *.log файлы в examples
# потому что это пример для документации
!examples/**/*.log

-----
Если нужно отобразить все игнорируемые файлы,
git status --ignored. В таком случае в выводе git status появится раздел Ignored files.
----------------------------------------------------------------------------

-l (List) - лист
-m (Modefy) - модифицировать
-b (branch) - ветка
-d (delete) - удалить
******************************************************************************
для пуша на удаленный репо : git remote add origin [тут ссылка на удаленный репо]
ПРИМЕР: git remote add origin https://github.com/DmitryBokhan/Slider2_adaptiv.git
git push -u origin master
******************************************************************************

git log
git log --oneline - короткий лог
git status - Проверить статус, или состояние репозитория
git pull
git push -u origin master
git config --global -l
git config -l
git config --system --unset credential.helper  (сбросит все настройки config) (работает только с правами администратора)
git config --global --unset credential.helper  (сбросит все настройки global) (работает только с правами администратора)

git fetch (далее вводим имя, почту и пароль) - создает новую ветку

git diff master..origin/master

**********************************
www.git-scm.com (устанавливаем Git на ПК)
git --version (проверяем версию)
git init (инициализируем Git в папке проекта)

значек "U" - (Untracked) в проекте означает что файл не отслеживается! (не добавлен в коммит)
значек "А" - означает что данный файл будет включен в следующий коммит
значек "M" - файл был ранее подготовлен для коммита, но после (до коммита) были внесены изменения (файл был модифицирован)
git status - команда показывает какие изменения есть в проекте (какие отслеживаются. а какие нет)

Статусы untracked/tracked, staged и modified
После выполнения команды git add файл попадает в staging area (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии staged.
tracked (англ. «отслеживаемый»)
modified (англ. «изменённый»)
Про staged и modified:
Команда git add добавляет в staging area только текущее содержимое файла. Если вы, например, сделаете git add file.txt, а затем измените file.txt, то новое содержимое файла не будет находиться в staging.

"коммит" - одна из версий изменений проекта

Перед тем как файл попадает в коммит, есть промежуточное состояние. Чтобы добавить файл в промижуточное состояние необхлдимо
написать команду : git add [имя файла]
Далее значек "U" (Untracked) изменится на "A"


git rm -f [имя файла] - команда удалит файл
git rm --cached [имя файла] - команда удалит файл из ПРОМЕЖУТОЧНОГО состояния "A". Данный файл не удалится из проекта, а только перестанит быть отслеживаемым (получит статус "U")

git mv [имя файла] [новое имя файла] - команда переименует файл

git commit -m "комментарий к коммиту" - комманда делает коммит файлов

git log - покажет все коммиты

---имена---
git config --global user.name - покажет глобальное имя пользователя
git config --global user.name "новое имя пользователя" - задаст новое имя Глобального пользователя

git config user.name - покажет локальное имя пользователя
git config user.name "новое имя пользователя" - задаст новое имя Локального пользователя

тоже самлое относится и к Email -> user.email
-----------------

----подготовка файлов к коммиту----
git add . - добавит все файлы проекта в статус "A" (подготовлен для коммита)
git add [имя файла] - добавит конкретный файл в статус "A" (подготовлен для коммита)
git add [имя файла] [имя файла] - добавит несколько конкретных файлов в статус "A" (подготовлен для коммита)

git add -p [имя файла] - позволяет добавить конкретные строки в "пред коммит - A"
-----------------------------------
git show - покажет последний коммит (детально)

-----сравнение коммитов ----
Для сравнения коммитов необходимо:
1. вывести список всех коммитов командой git log
2. пишем команду git diff [номер первого коммита] [номер второго коммита]

Второй ваиант сравнения
git diff HEAD~1 HEAD~2
где HEAD~1 - это текущее изменение, а HEDA~2 - педыдущее
т.е. моно указывать номера сравниваемых коммитов через конструкцию HEAD~№ коммита

Если нужно посмотреть какие файлы были изменены в коммитах (без детализации, только имена файлов) используй команду:
git diff --name-only HEAD HEAD~2 (сравниваем текущее состояние проекта с пред-пред идущим коммитом)

-----откат файла-----
Если ты подготовил вайл к коммиту, а затем внес изменения, то можно вернуться к изначальному состоянию файла при помощи команды:
git checkout [имя файла]

Это удобно в случаях если ты допустил ошибку и тебе нужно вернуть рабочее состояние проекта, тем самым файл вернется из состояния M -> A (из модифицированного до подготовленного к коммиту)
----------------------------------

-----откат коммитов-----
git reset --hard [номер коммита] - команда возвращается по ветке коммитов обратно, но при этом все изменения сделаные после коммита на который вернулись - удаляются! (не рекомендуют использовать)

git reset --soft [номер коммита] - возвращаемся к указанному коммиту, но при этом все изменения выше сохраняются (грубо говоря это отмена коммита)

git reset --mixed [номер коммита] - тоже удаляет ветки выше (как hard) и все изменения находлятся в состоянии коммита (т.е. не подготовлены к коммиту и не отслеживаются)
------------------------

-----создание клона репозитория---------
git clone [адрес репозитория]
Созается папка которая связана с аккаутном на GitHub/GitLab
-----------------------------------

------Получить последние состояние реп.-я с Git----------
git fetch - запрос последнеко состояния реп-я с Git
--------------------------

------сравниваем две ветки--------
*если на удаленном реп-ии были изменения, иногда полезно сравнить их с вашим текущим состоянием проекта. Для этого можно сравить ветку на локальном реп-ии с веткой на глобальном реп-ии.

git diff master..origin/master
где master - это локальный реп-й., а origin/master - реп.-й в GitHub

если нас устроили измененя на удаленном реп.-ии можно их загрузить на локальный реп. при помощи команды:
git pull - получаем актуальное состояние реп.-я
---------------------------------

------Создание новой ветки--------------
git checkout -b [имя ветки] - команда создаст новую ветку

git branch -l - покажет список всех веток (активная будет выделена *)

git branch -m - переименовать ветку

git config --global init.defaultBranch [новое имя главной ветки] - задаст (глобально) новое имя ветки по умолчанию, (сейчас это main у меня)

git checkout [имя ветки] - команда позволяет переключаться между ветками

git commit -a -m "Коментарии" - команда сразу коммитет изменения без предворительной подкотовки к коммитк (без git add .)

-------------------

git remote - покажет названия удаленных веток на Git
git remote -v покажет название и адрес удаленной ветки на Git
---------

-------отправка локальной ветки на удалегнный реп.-й------
git push -u origin [имя ветки] - добаит ветку с локатьного реп. на глобальный реп.
--------------------------------------------

--------получение ветки из глобального репо.-я на локальный ------
git fetch - получить ветки из глоб-го реп-я.
далее необходио переключиться на нужную ветку комндой git checkout [имя ветки]
-----------------------------------------------------------

-----изменить имя ветки-----
git branch -m [текущее имя ветки] [новое имяветки] - так можно поменять имя ветки
---------------------------------

------удаление ветки с удаленного репозитория------
git push --delete origin [имя ветки] - удалит ветку с удаленного реп.-я
-----------------------------------------------------

-----удаление ветки с локального репозитория -----
git branch -D [имя ветки]

Более безопасный вариант удаления ветки:
git branch -d [имя ветки]  (более безопасный вариант -удалит ветку только если она была полностью объединена с другой — то есть если две ветки стали (или изначально были) частью одной истории)

----------------------------------------------

----показать ветки на удаленном пер.----------
git branch -r - команда покажет вкетки на удаленном перю.
-----------------------------------------------

-------слияние веток-----------
git merge [имя ветки] - команда сольет текущую ветку в ветку выбранную после слова marge
------------------------



-----------слияние веток при помощи rebase ----
Второй способ объединения изменений в ветках - это rebasing. При ребейзе Git по сути копирует набор коммитов и переносит их в другое место.

Несмотря на то, что это звучит достаточно непонятно, преимущество rebase в том, что c его помощью можно делать чистые и красивые линейные последовательности коммитов. История коммитов будет чище, если вы применяете rebase.

git rebase [имя ветки с которой делаем слияние]
----------------------------------------------------


-----------HEAD---------------------
HEAD - это символическое имя текущего выбранного коммита — это, по сути, тот коммит, над которым мы в данным момент работаем.

HEAD всегда указывает на последний коммит из вашего локального дерева. Большинство команд Git, изменяющих рабочее дерево, начнут с изменения HEAD.

Обычно HEAD указывает на имя ветки (например, bugFix). Когда вы делаете коммит, статус ветки bugFix меняется и это изменение видно через HEAD.


------------------------------------

----------------------перемещение по ветке при помощи отностительны ссылок----------------
Перемещение на один коммит назад ^
Перемещение на коммитов назад ~<num>

Для начала рассмотрим оператор каретки (^). Когда мы добавляем его к имени ссылки, Git воспринимает это как указание найти родителя указанного коммита.

Так что main^ означает "первый родитель ветки main".

main^^ означает прародитель (родитель родителя) main


пример: git checkout main^  - в результате HEAD переместиться к родителю

-----------------------------------


------------Перемещение ветки (branch forcing)----------------
Теперь мы разбираемся в относительных ссылках, так что можно реально использовать их для дела.

Одна из наиболее распространённых целей, для которых используются относительные ссылки - это перемещение веток. Можно напрямую прикрепить ветку к коммиту при помощи опции -f. Например, команда:

git branch -f main HEAD~3

Переместит (принудительно) ветку main на три родителя назад от HEAD.
-----------

----------------Отмена изменений в Git-----------
Есть много путей для отмены изменений в Git. Так же как и коммит, отмена изменений в Git возможна и на низком уровне (добавление в коммит отдельных файлов и наборов строк), и на высоком (как изменения реально отменяются). Сейчас сфокусируемся на высокоуровневой части.

Есть два основных способа отмены изменений в Git: первый - это git reset, а второй - git revert.


----------

--------Git Reset и git revert -------------
git reset отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории"; git reset перенесёт ветку назад, как будто некоторых коммитов вовсе и не было.

Reset отлично работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие пользователи.

Чтобы отменить изменения и поделиться отменёнными изменениями с остальными, надо использовать git revert. Посмотрим, как это работает
------------------------------

-----------Git Cherry-pick-----------------
git cherry-pick <Commit1> <Commit2> <...>
Это очень простой и прямолинейный способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находишься (HEAD). Мы обожаем cherry-pick за то, что в нём очень мало магии и его очень просто понять и применять.
-------------------------------------------


-------Git Interactive Rebase--------------
Git cherry-pick прекрасен, когда точно известно, какие коммиты нужны (и известны их точные хеши)

Но как быть в случае, когда точно не известно какие коммиты нужны? К счастью, Git позаботился о таких ситуациях! Можно использовать интерактивный rebase для этого - лучший способ отобрать набор коммитов для rebase.

Всё, что нужно для интерактивного rebase - это опция -i

Если добавить эту опцию, Git откроет интерфейс просмотра того, какие коммиты готовы к копированию на цель rebase (target). Также показываются хеши коммитов и комментарии к ним, так что можно легко понять что к чему.

Для "реального" Git, этот интерфейс означает просто открытие файла в редакторе типа vim. Для этой обучалки, я сделал небольшое диалоговое окно, которое по сути делает то же, что и редактор.

----------------
-------------Git cherry-pick прекрасен, когда точно известно, какие коммиты нужны (и известны их точные хеши)--------------

Но как быть в случае, когда точно не известно какие коммиты нужны? К счастью, Git позаботился о таких ситуациях! Можно использовать интерактивный rebase для этого - лучший способ отобрать набор коммитов для rebase.

Всё, что нужно для интерактивного rebase - это опция -i

Если добавить эту опцию, Git откроет интерфейс просмотра того, какие коммиты готовы к копированию на цель rebase (target). Также показываются хеши коммитов и комментарии к ним, так что можно легко понять что к чему.

Для "реального" Git, этот интерфейс означает просто открытие файла в редакторе типа vim. Для этой обучалки, я сделал небольшое диалоговое окно, которое по сути делает то же, что и редактор.
----------------------

-------------------------
Вот ситуация, которая часто случается при разработке: мы пытаемся отследить ошибку, но она не очень очевидна. Для того, чтобы достичь успеха на этом поприще, мы используем несколько команд для отладки и вывода

Каждая отладочная команда (команды) вывода находится в своём коммите. В итоге мы нашли ошибку, исправили её и порадовались!

Но проблема в том, что мы хотим добавить в main только исправление ошибки из ветки bugFix. Если мы воспользуемся простым fast-forward, то в main попадут также отладочные команды. Должен быть другой способ...

Надо заставить git копировать только один из коммитов. Это почти как в предыдущем уровне – мы можем использовать уже известные нам команды:

git rebase -i
git cherry-pick
Чтобы достичь желаемого результата.
-----------------------

--------------------------Жонглируем коммитами №1-------------------
Вот ещё одна ситуация, которая часто случается. Есть некоторые изменения (newImage) и другие изменения (caption), которые связаны так, что находятся друг поверх друга в репозитории.

Штука в том, что иногда нужно внести небольшие изменения в более ранний коммит. В таком случае надо немного поменять newImage, несмотря на то, что коммит уже в прошлом!

Преодолеть эти трудности можно следующим образом:

Переставить коммит так, чтобы нужный находился наверху при помощи git rebase -i
Внести изменения при помощи git commit --amend
Переставить всё обратно при помощи git rebase -i
И наконец, переместить main на изменённую часть дерева, чтобы закончить уровень.
Это задание можно выполнить несколькими способами (и, гляжу, ты посматриваешь на cherry-picking), но сейчас сосредоточься на вышеописанном методе.

Обрати внимание на итоговое состояние в этом уровне – так как мы дважды перемещаем коммиты, оба они получат по апострофу. Ещё один апостроф добавляется, когда мы делаем git commit --amend.

Важно, чтобы совпадало не только дерево коммитов, но и количество апострофов.
----------------------------------------

--------------------------Жонглируем коммитами №2-------------------
Перед прохождением этого уровня обязательно надо пройти предыдущий уровень – 'Жонглируем коммитами №1'

В прошлом уровне мы использовали rebase -i, чтобы переставлять коммиты. Как только нужный нам коммит оказывался в конце, мы могли спокойно изменить его при помощи --amend и переставить обратно.

Единственная проблема тут - это множество перестановок, которые могут спровоцировать конфликты. Посмотрим, как с этой же задачей справится cherry-pick.

-----------------
-----------------Теги-----------------------
В прошлых уроках мы усвоили, что ветки просто двигать туда-сюда и они часто ссылаются на разные коммиты как на изменения данных в ветке. Ветки просто изменить, они часто временны и постоянно меняют своё состояние.

В таком случае, где взять постоянную ссылку на момент в истории изменений? Для таких вещей, как релиз, большие слияния нужно нечто более постоянное, чем ветка.

Такое средство имеется. Git предоставляет нам теги, чья основная задача – ссылаться постоянно на конкретный коммит.

Важно, что после создания они никогда не сменят своего положения, так что можно с лёгкостью сделать checkout конкретного момента в истории изменений

git tag v1 C1 - (это пример) - команда сосздаст тег v1 на ветке C1
------------------------------------------------

-----------------Git Describe---------------------------
Теги являются прекрасными ориентирами в истории изменений, поэтому в git есть команда, которая показывает, как далеко текущее состояние от ближайшего тега. И эта команда называется git describe

Git describe помогает сориентироваться после отката на много коммитов по истории изменений. Такое может случиться, когда вы сделали git bisect или если вы недавно вернулись из отпуска =)
Git describe выглядит примерно так:

git describe <ref>

Где ref — это что-либо, что указывает на конкретный коммит. Если не указать ref, то git будет считать, что указано текущее положение (HEAD).

Вывод команды выглядит примерно так:

<tag>_<numCommits>_g<hash>

Где tag – это ближайший тег в истории изменений, numCommits – это на сколько далеко мы от этого тега, а hash – это хеш коммита, который описывается.


----------------Определение родителей-----------------------
Так же как тильда (~), каретка (^) принимает номер после себя.

Но в отличие от количества коммитов, на которые нужно откатиться назад (как делает ~), номер после ^ определяет, на какого из родителей мерджа надо перейти. Учитывая, что мерджевый коммит имеет двух родителей, просто указать ^ нельзя.

Git по умолчанию перейдёт на "первого" родителя коммита, но указание номера после ^ изменяет это поведение.

Вот мерджевый коммит (C3).
C0         
/ \
C1  C2
|  /
C3 (main*)

Если мы перейдём на main^ без номера, то попадём на первого родителя.

git checkout main^

                                   C0         
                                  / \
                           HEAD->C1  C2
                                 |  /
                                 C3 (main)

(На нашей визуализации первый родитель находится прямо над коммитом)

Теперь попробуем перейти на второго родителя.

git checkout main^2

                                   C0         
                                  / \
                                 C1  C2 <-HEAD
                                 |  /
                                 C3 (main)
                                 
                                 Вот. Мы на втором родительском коммите.



------- ^~-------------
Модификаторы ^ и ~ сильно помогают перемещаться по дереву коммитов:

          C0
          /\
        C1  C3
         |   |
        C2  C4
         |   |
         |  C5
         | /       
         C6 
          |
          C7 <- main*

git checkout HEAD~;
git checkout HEAD^2;
git checkout HEAD~2;

          C0
          /\
        C1  C3 <- HEAD
         |   |
        C2  C4
         |   |
         |  C5
         | /       
         C6 
          |
          C7 <- main

Более того, эти модификаторы можно применять вместе. Например, так:

git checkout HEAD~^2~2   (аналогично трем операциям выше)

----------Создане удаленного репозитория----------

git clone  [ссылка на удаленный реп.]

Появится новая ветка с именем origin/main. Такой тип ветки называется удалённой веткой. Поскольку удалённые ветки играют важную и уникальную роль, они обладают рядом специальных свойств.Удалённые ветки отражают состояние удалённых репозиториев (с того момента, как вы обращались к этим удалённым репозиториям в последний раз). Они позволяют вам отслеживать и видеть разницу между вашими локальными наработками и тем, что было сделано другими участниками - важный шаг, который необходимо делать, прежде чем делиться своими наработками с другими.
Важным свойством удалённых веток является тот факт, что когда вы извлекаете их, вы отделяете (detaching) HEAD. Git делает это потому, что вы не можете работать непосредственно в этих ветках; сперва вам необходимо сделать наработки где-либо, а уж затем делиться ими с удалёнными репозиториями (после чего ваши удалённые ветки будут обновлены).

Удалённые ветки также имеют (обязательное) правило именования - они отображаются в формате:

<удалённый репозиторий>/<имя ветки>
--------------------------------------------------


----------------------Git Fetch----------------
git fetch позволяет извлкекать дынные из удаленного репозитория

Что делает fetch
git fetch выполняет две и только две основные операции. А именно:

- связывается с указанным удалённым репозиторием и забирает все те данные проекта, которых у вас ещё нет, при этом...
- у вас должны появиться ссылки на все ветки из этого удалённого репозитория (например, origin/main)

Фактически, git fetch синхронизирует локальное представление удалённых репозиториев с тем, что является актуальным на текущий момент времени.

Насколько вы помните, в предыдущем уроке мы сказали, что удалённые ветки отображают состояние удалённых репозиториев на тот момент когда вы 'общались' с ними в последний раз. git fetch является тем механизмом, который даёт вам возможность общаться с удалёнными репозиториями! Надеюсь, что связь между удалёнными ветками и командой git fetch теперь прояснилась.

git fetch обычно 'общается' с удалёнными репозиториями посредством Интернета (через такие протоколы, как http:// или git://).

Чего fetch не делает
Важно отметить, что команда git fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент.

Важно это помнить и понимать, потому что многие разработчики думают, что, запустив команду git fetch, они приведут всю свою локальную работу к такому же виду, как и на удалённом репозитории. Команда всего лишь скачивает все необходимые данные, но вам потребуется вручную слить эти данные с вашими.
Одним словом, вы можете относиться к git fetch как к процедуре скачивания.
------------------------------------------------------------------



------------Git Pull------------------------------
Теперь, когда мы познакомились с тем, как извлекать данные из удалённого репозитория с помощью git fetch, давайте обновим нашу работу, чтобы отобразить все эти изменения!

Существует множество вариантов решений - как только у вас имеется локальный коммит, вы можете соединить его с другой веткой. Это значит, вы можете выполнить одну из команд:

git cherry-pick o/main
git rebase o/main
git merge o/main
и т.д.
Процедура скачивания (fetching) изменений с удалённой ветки и объединения (merging) настолько частая и распространённая, что git предоставляет вместо двух команд - одну! Эта команда - git pull.
--------------------------------------------

----------------Совместная работа -----------------
git fakeTeamwork

Поведение команды fakeTeamwork по умолчанию заключается в том, чтобы просто "инициировать" коммит на main-е.

git fakeTeamwork [имя ветки] [колличество добавляемых коммитов]

В данной команде вам доступна возможность указать ветку и количество добавляемых коммитов

С помощью одной лишь команды мы симулируем добавление трёх коммитов в ветку foo на удалённом репозитории
------------------------

-------------------Git Push-------------------
Вы можете рассматривать команду git push как "публикацию" своей работы. Эта команда скрывает в себе множество тонкостей и нюансов, с которыми мы познакомимся в ближайшее время, а пока что давайте начнём с малого...

замечание - поведение команды git push без аргументов варьируется в зависимости от значения push.default, указанной в настройках git-а. Значение по умолчанию зависит от версии git, которую вы используете, однако в наших уроках мы будем использовать значение upstream. Лучше всегда проверять эту опцию прежде чем push-ить ваши настоящие проекты.
